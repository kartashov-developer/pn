TypeScript Learning @

TypeScript Simplified .
  . Smaller and more easier.
  - 7 hours
  - 5/56
  ✔ 01 - What Is TypeScript + Course Introduction - 00:03:34
  ✔ 02 - Why Use TypeScript - 00:05:06
  ✔ 03 - How To Initialize A TypeScript Project - 00:04:30
  ✔ 04 - Using A Bundler - 00:03:38
  ✔ 05 - Understanding The TSConfig - 00:04:55
  ✘ 06 - Assigning Types And Type Inference - 00:06:28
  ✘ 07 - Array Type - 00:03:27
  ✘ 08 - Any Type - 00:03:23
  ✘ 09 - Object Basics - 00:03:39
  ✘ 10 - Types Vs Interfaces - 00:05:50
  ✘ 11 - Defining Functions - 00:06:57
  ✘ 12 - Void Type - 00:02:20
  ✘ 13 - Optional Parameters - 00:01:35
  ✘ 14 - Destructured And Rest Parameters - 00:05:59
  ✘ 15 - Typing Variables As Functions - 00:03:38
  ✘ 16 - Unions - 00:05:22
  ✘ 17 - Intersections - 00:04:59
  ✘ 18 - readonly - 00:02:30
  ✘ 19 - keyof - 00:02:38
  ✘ 20 - typeof - 00:03:15
  ✘ 21 - Index Types - 00:09:47
  ✘ 22 - As Const And Enums - 00:06:23
  ✘ 23 - Tuples - 00:02:24
  ✘ 24 - Generics - 00:20:50
  ✘ 25 - Async Functions - 00:02:22
  ✘ 26 - Pick And Omit - 00:05:06
  ✘ 27 - Partial And Required - 00:06:37
  ✘ 28 - ReturnType And Parameters - 00:03:26
  ✘ 29 - Record - 00:01:32
  ✘ 30 - Readonly - 00:02:01
  ✘ 31 - Awaited - 00:01:30
  ✘ 32 - Basic Type Guards - 00:10:30
  ✘ 33 - Never Type - 00:02:52
  ✘ 34 - Unknown Type - 00:02:56
  ✘ 35 - As Casting - 00:04:18
  ✘ 36 - Satisfies - 00:03:48
  ✘ 37 - Discriminated Union - 00:04:53
  ✘ 38 - Function Overloads - 00:05:26
  ✘ 39 - Type Predicate Function - 00:08:15
  ✘ 40 - Debugging - 00:10:29
  ✘ 41 - Importing Types - 00:05:35
  ✘ 42 - Declaration Files - 00:06:25
  ✘ 43 - Todo List Project Introduction - 00:01:32
  ✘ 44 - Todo List Project Walkthrough - 00:14:53
  ✘ 45 - Migrate JS To TS Project Introduction - 00:03:29
  ✘ 46 - Migrate JS To TS Project Walkthrough - 00:24:24
  ✘ 47 - What's Next - 00:01:54
  ✘ 01 Bonus - PropTypes - 00:11:09
  ✘ 02 Bonus - TypeScript Setup And Props - 00:11:21
  ✘ 03 Bonus - useState - 00:02:58
  ✘ 04 Bonus - useRef - 00:04:05
  ✘ 05 Bonus - useReducer - 00:03:43
  ✘ 06 Bonus - useContext - 00:06:16
  ✘ 07 Bonus - Generic Components - 00:04:26
  ✘ 08 Bonus - Google Calendar Clone Introduction - 00:07:08
  ✘ 09 Bonus - Google Calendar Clone Walkthrough - 01:44:43
Mastering TypeScript - 2023 Edition .
  - 11 hours
  ✘ 1. 00:02:08 Welcome & Course Overview
  ✘ 2. 00:01:44 Course Prerequisites
  ✘ 3. 00:03:44 The Case For TypeScript
  ✘ 4. 00:05:06 TypeScript Overview
  ✘ 5. 00:02:57 Installing TypeScript
  ✘ 6. 00:02:55 The TypeScript Playground
  ✘ 7. 00:01:54 Installing Visual Studio Code
  ✘ 8. 00:05:52 How We Use TypeScript
  ✘ 9. 00:04:18 Our First Type Annotation
  ✘ 10. 00:01:56 Working With Numbers & Booleans
  ✘ 11. 00:03:21 Compiling TypeScript
  ✘ 12. 00:02:40 Type Inference
  ✘ 13. 00:02:03 The Any Type
  ✘ 14. 00:03:32 Delayed Initialization & Implicit Any
  ✘ 15. 00:04:21 Function Parameter Annotations
  ✘ 16. 00:01:53 More On Function Parameter Annotations
  ✘ 17. 00:01:50 Working With Default Parameters
  ✘ 18. 00:06:09 Return Type Annotations
  ✘ 19. 00:02:19 Anonymous Function Contextual Typing
  ✘ 20. 00:01:58 The Void Type
  ✘ 21. 00:03:11 The Never Type
  ✘ 22. 00:05:07 Function Types EXERCISE
  ✘ 23. 00:04:03 Working With Object Types
  ✘ 24. 00:02:54 More Object Types
  ✘ 25. 00:02:52 Excess Properties
  ✘ 26. 00:04:02 Creating Type Aliases
  ✘ 27. 00:07:37 Nested Objects
  ✘ 28. 00:01:30 Optional Properties
  ✘ 29. 00:02:27 The readonly Modifier
  ✘ 30. 00:04:02 Intersection Types
  ✘ 31. 00:05:16 Object Types EXERCISE
  ✘ 32. 00:04:00 Working With Array Types
  ✘ 33. 00:02:24 More Array Syntax
  ✘ 34. 00:01:49 Multidimensional Arrays
  ✘ 35. 00:03:34 Array Types EXERCISE
  ✘ 36. 00:04:00 Introducing Union Types
  ✘ 37. 00:07:57 Type Narrowing w/ Union Types
  ✘ 38. 00:04:24 Union Types and Arrays
  ✘ 39. 00:04:16 Literal Types
  ✘ 40. 00:06:45 Union Types EXERCISE
  ✘ 41. 00:03:55 Introducing Tuples
  ✘ 42. 00:06:34 A Bit More On Tuples
  ✘ 43. 00:06:16 Introducing Enums
  ✘ 44. 00:03:09 A Bit More On Enums!
  ✘ 45. 00:05:31 Enums Behind The Scenes
  ✘ 46. 00:03:46 Introducing Interfaces
  ✘ 47. 00:02:15 Readonly and Optional Interface Properties
  ✘ 48. 00:02:41 Interface Methods
  ✘ 49. 00:03:35 Interface Method Parameters
  ✘ 50. 00:02:38 Reopening Interfaces
  ✘ 51. 00:03:23 Extending Interfaces
  ✘ 52. 00:03:23 Interface Multiple Inheritance
  ✘ 53. 00:04:09 Interfaces Vs. Type Aliases
  ✘ 54. 00:05:17 Compiling to JavaScript
  ✘ 55. 00:02:17 Watch Mode
  ✘ 56. 00:04:01 Working With Multiple Files
  ✘ 57. 00:03:43 The Files Compiler Option
  ✘ 58. 00:05:52 Include & Exclude Options
  ✘ 59. 00:01:38 Outdir Option
  ✘ 60. 00:02:16 Target Option
  ✘ 61. 00:05:23 Strict Option
  ✘ 62. 00:02:26 Compiler Options Wrap Up
  ✘ 63. 00:07:21 A Simple Project Setup
  ✘ 64. 00:07:30 Working With The DOM
  ✘ 65. 00:06:18 The Lib Compiler Option
  ✘ 66. 00:06:49 TypeScript's Non-Null Assertion Operator
  ✘ 67. 00:02:50 Type Assertions
  ✘ 68. 00:07:43 Type Assertions With the DOM
  ✘ 69. 00:05:58 Working With Events
  ✘ 70. 00:06:52 Building The Todo List
  ✘ 71. 00:05:09 Adding in an Interface
  ✘ 72. 00:07:11 Connecting to LocalStorage
  ✘ 73. 00:05:55 Todo List Finishing Touches
  ✘ 74. 00:04:20 Classes Setup
  ✘ 75. 00:04:19 The Class Keyword
  ✘ 76. 00:03:11 Constructors
  ✘ 77. 00:03:58 Class Fields
  ✘ 78. 00:06:20 Private Fields
  ✘ 79. 00:02:58 Getters
  ✘ 80. 00:05:44 Setters
  ✘ 81. 00:04:02 Static Properties & Methods
  ✘ 82. 00:03:10 Extending Classes
  ✘ 83. 00:04:45 The Dreaded Super()
  ✘ 84. 00:04:05 Annotating Classes In TypeScript
  ✘ 85. 00:02:01 Class Fields In TypeScript
  ✘ 86. 00:01:20 readonly Class Properties
  ✘ 87. 00:02:10 The public Modifier
  ✘ 88. 00:05:42 The private Modifier
  ✘ 89. 00:03:11 Parameter Properties Shorthand
  ✘ 90. 00:04:47 Getters and Setters
  ✘ 91. 00:03:01 The Protected Modifier
  ✘ 92. 00:05:09 Classes and Interfaces
  ✘ 93. 00:08:49 Creating Abstract Classes
  ✘ 94. 00:05:39 Introducing Generics
  ✘ 95. 00:08:02 Another Example Of A Built-In Generic
  ✘ 96. 00:07:13 Writing Our First Generic
  ✘ 97. 00:05:18 Writing Another Generic Function
  ✘ 98. 00:03:15 Inferred Generic Type Parameters
  ✘ 99. 00:02:18 Generics, Arrow Functions, & TSX Files
  ✘ 100. 00:05:36 Generics With Multiple Types
  ✘ 101. 00:04:44 Adding Type Constraints
  ✘ 102. 00:02:52 Default Type Parameters
  ✘ 103. 00:03:28 Writing Generic Classes
  ✘ 104. 00:05:25 Typeof Guards
  ✘ 105. 00:05:32 Truthiness Guards
  ✘ 106. 00:03:35 Equality Narrowing
  ✘ 107. 00:06:20 Narrowing With The In Operator
  ✘ 108. 00:05:54 Instanceof Narrowing
  ✘ 109. 00:06:36 Working With Type Predicates
  ✘ 110. 00:10:44 Discriminated Unions
  ✘ 111. 00:04:32 Exhaustiveness Checks With Never
  ✘ 112. 00:04:31 Introducing Type Declarations
  ✘ 113. 00:05:50 Using 3rd Party Libraries: Axios
  ✘ 114. 00:11:55 Working With Axios Types
  ✘ 115. 00:08:11 Installing Types Separately
  ✘ 116. 00:03:39 A Note On Namespaces
  ✘ 117. 00:05:38 Working Without Modules
  ✘ 118. 00:05:45 Using TypeScript Modules
  ✘ 119. 00:06:37 Changing Compilation Module System
  ✘ 120. 00:06:29 Import/Export Syntax In Depth
  ✘ 121. 00:05:42 Importing Types
  ✘ 122. 00:04:24 What's The Point Of Webpack?
  ✘ 123. 00:11:37 Setting Up a Project
  ✘ 124. 00:04:10 Installing Webpack Dependencies
  ✘ 125. 00:11:00 Basic Webpack Config
  ✘ 126. 00:02:36 Adding Source Maps
  ✘ 127. 00:03:29 Webpack Dev Server
  ✘ 128. 00:07:16 Production Configuration
  ✘ 129. 00:03:45 React & TypeScript Introduction
  ✘ 130. 00:08:16 Create React App With TypeScript
  ✘ 131. 00:05:33 Our First Component
  ✘ 132. 00:02:36 A Note on React.FC
  ✘ 133. 00:04:01 Props With TypeScript
  ✘ 134. 00:07:52 Creating Our ShoppingList Component
  ✘ 135. 00:05:21 useState With TypeScript
  ✘ 136. 00:03:46 Creating Our ShoppingItem Form
  ✘ 137. 00:07:41 useRef With TypeScript
  ✘ 138. 00:03:00 Updating The State
  ✘ 139. 00:04:30 Finishing Touches
  ✘ 140. 00:02:01 React + TypeScript Wrapup

Total TypeScript - Matt Pocock .
  - 24 hours
  ✘ 1. 00:01:09 Type Transformations Workshop Welcome: Explainer
  ✘ 2. 00:00:40 Get the Return Type of a Function
  ✘ 3. 00:01:31 Use a Utility Type to Extract a Function’s Return Type
  ✘ 4. 00:02:02 Typeof Keyword, and Type Level
  ✘ 5. 00:00:25 Extract Function Parameters Into A Type
  ✘ 6. 00:00:46 Use a Utility Type to Extract Function Parameters
  ✘ 7. 00:00:38 Extract The Awaited Result of a Promise
  ✘ 8. 00:00:59 Use Utility Types To Extract a Promise's Result
  ✘ 9. 00:00:34 Create a Union Type From an Object’s Keys
  ✘ 10. 00:01:31 Create Unions from Objects Using Two Operators
  ✘ 11. 00:00:23 Understand The Terminology Around Unions
  ✘ 12. 00:01:41 Union Terminology Examples
  ✘ 13. 00:00:46 Extracting Members of a Discriminated Union
  ✘ 14. 00:01:42 Extract From A Union Using a Utility Type
  ✘ 15. 00:00:20 Excluding Parts of a Discriminated Union
  ✘ 16. 00:00:32 Use a Utility Type to Remove a Single Member of a Union
  ✘ 17. 00:02:47 The Power of Union Types in TypeScript: Explainer
  ✘ 18. 00:00:40 Extract Object Properties into Individual Types
  ✘ 19. 00:01:06 Use Indexed Access Types to Extract Object Properties
  ✘ 20. 00:00:25 Extract the Discriminator from a Discriminated Union
  ✘ 21. 00:00:57 Simple Syntax Used to Access Parts of a Discriminated Union
  ✘ 22. 00:01:02 Resolve an Object’s Values as Literal Types
  ✘ 23. 00:02:23 The Annotation Used to Infer an Object's Values as Literal Types
  ✘ 24. 00:00:53 Create a Union From an Object's Values
  ✘ 25. 00:01:12 Extract Specific Members From A Union with Indexed Access
  ✘ 26. 00:00:27 Get All of an Object’s Values
  ✘ 27. 00:00:56 Use Two Operators With Indexed Access to Get All of an Object's Values
  ✘ 28. 00:00:29 Create Unions out of Array Values
  ✘ 29. 00:01:24 Methods Used to Create Unions out of Array Values
  ✘ 30. 00:00:43 Only Allow Specified String Patterns
  ✘ 31. 00:01:09 Template Literal with Strings
  ✘ 32. 00:01:01 Extract Union Strings Matching a Pattern
  ✘ 33. 00:01:02 Extracting String Pattern Matches with Template Literals
  ✘ 34. 00:00:36 Create a Union of Strings with All Possible Permutations of Two Unions
  ✘ 35. 00:01:08 Passing Unions Into Template Literals
  ✘ 36. 00:00:45 Splitting A String into a Tuple
  ✘ 37. 00:01:01 Using S From ts-toolbelt to Split a String Into a Tuple
  ✘ 38. 00:00:35 Create an Object Whose Keys Are Derived From a Union
  ✘ 39. 00:00:58 Use a Utility Type to Create An Object From A Union
  ✘ 40. 00:00:33 Transform String Literals To Uppercase
  ✘ 41. 00:01:12 Manipulate String Literals Using Type Helpers
  ✘ 42. 00:01:55 Template Literals in Mattermost: Explainer
  ✘ 43. 00:00:42 Introducing Type Helpers
  ✘ 44. 00:02:46 Create Functions that Return Types
  ✘ 45. 00:00:23 Creating a Maybe Type Helper
  ✘ 46. 00:01:17 The Unconstrained Maybe Type Helper
  ✘ 47. 00:01:06 Ensure Type Safety in a Type Helper
  ✘ 48. 00:03:01 Use Constraints to Limit Type Parameters
  ✘ 49. 00:00:27 Create a Reusable Type Helper
  ✘ 50. 00:00:36 Add Support for Multiple Types in a Type Helper
  ✘ 51. 00:00:43 Optional Type Parameters in Type Helpers
  ✘ 52. 00:01:53 Set a Default Type Value in a Type Helper
  ✘ 53. 00:00:59 Functions as Constraints for Type Helpers
  ✘ 54. 00:02:42 Support Function Type Constraints with Variable Arguments
  ✘ 55. 00:00:43 Constraining Types for Anything but null or undefined
  ✘ 56. 00:03:35 Exclude null and undefined from the Maybe Type
  ✘ 57. 00:00:33 Constraining Type Helpers to Non-Empty Arrays
  ✘ 58. 00:01:58 Enforce a Minimum Array Length in a Type Helper
  ✘ 59. 00:04:59 Explainer: Type Helpers in Redux
  ✘ 60. 00:00:39 Add Conditional Logic to a Type Helper
  ✘ 61. 00:02:27 Compare and Return Values with Extends and the Ternary Operator
  ✘ 62. 00:01:00 Refine Conditional Logic in a Type Helper
  ✘ 63. 00:02:22 Prevent Unwanted Type Scenarios from Happening
  ✘ 64. 00:01:45 How TypeScript Added Conditional Types: Explainer
  ✘ 65. 00:01:09 Introducing infer for Conditional Logic
  ✘ 66. 00:02:43 Infer Elements Inside a Conditional with Infer
  ✘ 67. 00:01:00 Extract Type Arguments to Another Type Helper
  ✘ 68. 00:02:36 Use infer with Generics to Extract Types from Arguments
  ✘ 69. 00:00:31 Extract Parts of a String with a Template Literal
  ✘ 70. 00:01:27 Pattern Matching on Template Literals with Infer
  ✘ 71. 00:02:51 Template Literal Types Were Nearly Regexes: Explainer
  ✘ 72. 00:00:52 Extract the Result of an Async Function
  ✘ 73. 00:01:23 Optionally Infer the Return Type of a Function
  ✘ 74. 00:00:52 Extract the Result From Several Possible Function Shapes
  ✘ 75. 00:01:17 Two Methods for Extracting the Result of Multiple Possible Functions 
  ✘ 76. 00:00:56 Distributivity in Conditional Types 
  ✘ 77. 00:03:03 Using Generic Context to Avoid Distributive Conditional Types
  ✘ 78. 00:00:40 Map Over a Union to Create an Object
  ✘ 79. 00:02:03 Use Mapped Types to Create an Object from a Union
  ✘ 80. 00:00:36 Mapped Types with Objects
  ✘ 81. 00:02:25 Map Over the Keys of an Object
  ✘ 82. 00:00:54 Transforming Object Keys in Mapped Types
  ✘ 83. 00:02:10 Remapping Object Keys in a Mapped Type
  ✘ 84. 00:01:45 How Excalidraw uses Mapped Types to Save Lines of Code: Explainer
  ✘ 85. 00:00:53 Conditionally Extract Properties from Object
  ✘ 86. 00:03:15 Selective Remapping with Conditional Types and Template Literals
  ✘ 87. 00:00:49 Map a Discriminated Union to an Object
  ✘ 88. 00:03:29 Two Techniques for Mapping a Discriminated Union to an Object
  ✘ 89. 00:00:52 Map an Object to a Union of Tuples
  ✘ 90. 00:02:05 Create a Union of Tuples by Reindexing a Mapped Type
  ✘ 91. 00:00:27 Transform an Object into a Union of Template Literals
  ✘ 92. 00:01:57 Map an Object to a Union of Template Literals
  ✘ 93. 00:00:33 Transform a Discriminated Union into a Union
  ✘ 94. 00:02:15 Iteratively Map and Remap to Transform Types
  ✘ 95. 00:01:01 Transform Path Parameters from Strings to Objects
  ✘ 96. 00:03:32 Extract from String with Mapped Types, Template Literals, and infer.
  ✘ 97. 00:00:36 Transform an Object into a Discriminated Union
  ✘ 98. 00:02:40 Create a Discriminated Union through Intermediary Transformations
  ✘ 99. 00:01:06 Transform a Discriminated Union with Unique Values to an Object
  ✘ 100. 00:02:14 Create an Object using Mapped Types, Conditional Types, and TypeScript Keywords
  ✘ 101. 00:01:02 Construct a Deep Partial of an Object
  ✘ 102. 00:05:17 Use Recursion and Mapped Types to Create a Type Helper
  ✘ 103. 00:01:17 TypeScript Generics Workshop Welcome
  ✘ 104. 00:00:46 Typing Functions with Generics
  ✘ 105. 00:01:54 Replace the unknown Type with a Generic
  ✘ 106. 00:00:40 Restricting Generic Argument Types
  ✘ 107. 00:00:56 Add Constraints to a Generic
  ✘ 108. 00:00:31 Typing Independent Parameters
  ✘ 109. 00:01:20 Use Multiple Generics with a Function
  ✘ 110. 00:00:28 Approaches for Typing Object Parameters
  ✘ 111. 00:01:51 Approaches for Typing Object Parameters: Solution
  ✘ 112. 00:02:20 Generic Functions in Excalidraw
  ✘ 113. 00:00:47 Generics in Classes
  ✘ 114. 00:01:11 Add Types to a Class
  ✘ 115. 00:01:04 Generic Mapper Function
  ✘ 116. 00:02:15 Add Object Property Constraints to a Generic
  ✘ 117. 00:01:29 The Importance of Generics in TypeScript
  ✘ 118. 00:00:45 Add Type Parameters to a Function
  ✘ 119. 00:02:51 Pass Type Arguments to a Function
  ✘ 120. 00:00:33 Defaults in Type Parameters
  ✘ 121. 00:00:45 Specify a Default Value
  ✘ 122. 00:01:08 Infer Types from Type Arguments
  ✘ 123. 00:02:12 Infer from the Type Arguments of a Class
  ✘ 124. 00:01:12 Strongly Type a Reduce Function
  ✘ 125. 00:03:06 Pass Type Arguments to a Reduce Function
  ✘ 126. 00:00:36 Avoid any Types with Generics
  ✘ 127. 00:03:47 Use Generics to Type a Fetch Request
  ✘ 128. 00:02:03 Passing Type Arguments in cal.com
  ✘ 129. 00:03:38 Improving Code Maintainability
  ✘ 130. 00:01:26 Generics at Different Levels
  ✘ 131. 00:03:04 Represent Generics at the Lowest Level
  ✘ 132. 00:00:47 Typed Object Keys
  ✘ 133. 00:03:45 Two Approaches for Typing Object Keys
  ✘ 134. 00:01:51 Make a Generic Wrapper for a Function
  ✘ 135. 00:04:49 Constrain a Type Argument to a Function
  ✘ 136. 00:03:54 Understand Literal Inference in Generics
  ✘ 137. 00:03:33 Understand Generic Inference When Using Objects as Arguments
  ✘ 138. 00:00:55 Inferring Literal Types from any Basic Type
  ✘ 139. 00:00:57 Accepting Multiple Literal Types
  ✘ 140. 00:00:57 Infer the Type of an Array Member
  ✘ 141. 00:02:14 Constrain to the Array Member, Not the Array
  ✘ 142. 00:01:33 Generics in a Class Names Creator
  ✘ 143. 00:01:44 Two Approaches to Working with Class Names
  ✘ 144. 00:04:50 Generics in React Query
  ✘ 145. 00:01:00 Generics with Conditional Types
  ✘ 146. 00:03:25 Ensure Runtime Level & Type Level Safety with Conditional Types
  ✘ 147. 00:01:22 Fixing Errors in Generic Functions
  ✘ 148. 00:02:30 Fixing the "Not Assignable" Error
  ✘ 149. 00:01:08 Generic Function Currying
  ✘ 150. 00:03:21 Fix Type Inference in Curried Functions
  ✘ 151. 00:02:28 Generic Interfaces with Functions
  ✘ 152. 00:04:32 Understanding Generics at Different Levels of Functions
  ✘ 153. 00:00:58 Spotting Useless Generics
  ✘ 154. 00:01:32 Refactoring Functions with Unnecessary Type Arguments
  ✘ 155. 00:01:32 Spotting Missing Generics
  ✘ 156. 00:02:53 Improving Type Inference with Additional Generics
  ✘ 157. 00:03:33 How tRPC Handles Inheritable Generics
  ✘ 158. 00:01:37 Refactoring Generics for a Cleaner API
  ✘ 159. 00:02:11 Create a Factory Function to Apply Type Arguments to All Child Functions
  ✘ 160. 00:01:53 The Partial Inference Problem
  ✘ 161. 00:03:57 A Workaround for The Lack of Partial Inference
  ✘ 162. 00:00:42 What is a Function Overload?
  ✘ 163. 00:01:08 Understanding Function Overloads
  ✘ 164. 00:00:32 Function Overloads vs. Conditional Types
  ✘ 165. 00:03:29 Match Return Types with Function Overloads
  ✘ 166. 00:01:18 Debugging Overloaded Functions
  ✘ 167. 00:03:53 Specifying Types for an Overloaded Function
  ✘ 168. 00:00:46 Function Overloads vs. Union Types
  ✘ 169. 00:02:03 When to Use Overloads and Unions
  ✘ 170. 00:00:43 Generics in Function Overloads
  ✘ 171. 00:02:50 Typing Different Function Use Cases
  ✘ 172. 00:01:00 Solving an Inference Mystery
  ✘ 173. 00:06:10 The Inference Mystery Solved
  ✘ 174. 00:01:17 Use Function Overloads to Infer Initial Data
  ✘ 175. 00:02:11 Split Functions Into Two Different Call Signatures
  ✘ 176. 00:01:48 The "Instantiated with Subtype" Error
  ✘ 177. 00:03:52 Handling Default Arguments with Function Overloads
  ✘ 178. 00:01:17 Make An Infinite Scroll Function Generic with Correct Type Inference
  ✘ 179. 00:05:03 Introduce a Type Parameter to Ensure Type Consistency
  ✘ 180. 00:01:34 Create a Function with a Dynamic Number of Arguments
  ✘ 181. 00:03:44 Use a Tuple to Represent a Dynamic Number of Arguments
  ✘ 182. 00:01:10 Create a Pick Function
  ✘ 183. 00:07:54 Extracting Object Properties with Reduce and Generics
  ✘ 184. 00:02:02 Create a Form Validation Library
  ✘ 185. 00:06:34 Add Strong Typing and Proper Error Handling to a Form Validator
  ✘ 186. 00:01:20 Improve a Fetch Function to Handle Missing Type Arguments
  ✘ 187. 00:01:55 Modify a Generic Type Default for Improved Error Messages
  ✘ 188. 00:02:22 Typing a Function Composition with Overloads and Generics
  ✘ 189. 00:05:53 Using Overloads and Generics to Type Function Composition
  ✘ 190. 00:02:32 Build an Internationalization Library
  ✘ 191. 00:07:46 Extract Types from Strings for an Internationalization Library
  ✘ 192. 00:01:14 Advanced Workshop Welcome
  ✘ 193. 00:03:23 What is a Branded Type?
  ✘ 194. 00:01:39 Form Validation with Branded Types
  ✘ 195. 00:01:38 Assigning Branded Types to Values
  ✘ 196. 00:00:43 Using Branded Types as Entity Id’s
  ✘ 197. 00:02:54 Add Branded Types to Functions and Models
  ✘ 198. 00:01:10 Creating Reusable Validity Checks with Branded Types and Type Helpers
  ✘ 199. 00:01:52 Combine Type Helpers with Branded Types
  ✘ 200. 00:01:54 Creating Validation Boundaries with Branded Types
  ✘ 201. 00:03:45 Using Branded Types to Validate Code Logic
  ✘ 202. 00:01:14 Using Index Signatures with Branded Types
  ✘ 203. 00:02:20 Indexing an Object with Branded Types
  ✘ 204. 00:01:02 TypeScript's Global Scope
  ✘ 205. 00:04:37 Add a Function to the Global Scope
  ✘ 206. 00:01:03 Add Functionality to Existing Global Interfaces
  ✘ 207. 00:04:43 Use Declaration Merging to Add Functionality to the Global Window
  ✘ 208. 00:01:03 Add Types to Properties of Global Namespaced Interfaces
  ✘ 209. 00:03:26 Typing process.env in the NodeJS Namespace
  ✘ 210. 00:02:00 Colocating Types for Global Interfaces
  ✘ 211. 00:02:56 Solving the Colocation Problem with Globals
  ✘ 212. 00:00:49 Filtering with Type Predicates
  ✘ 213. 00:02:56 Use a Type Predicate to Filter Types
  ✘ 214. 00:01:13 Checking Types with Assertion Functions
  ✘ 215. 00:02:46 Ensure Valid Types with an Assertion Function
  ✘ 216. 00:00:48 Avoiding TypeScript's Most Confusing Error
  ✘ 217. 00:00:37 Declare Assertion Functions Properly to Avoid Confusing Errors
  ✘ 218. 00:01:45 Combining Type Predicates with Generics
  ✘ 219. 00:02:35 Filtering with Type Predicates and Generics
  ✘ 220. 00:00:50 Combining Brands and Type Predicates
  ✘ 221. 00:00:44 Checking for Validity with Brands and Type Predicates
  ✘ 222. 00:00:24 Combining Brands with Assertion Functions
  ✘ 223. 00:01:05 Validate Types with Brands and Assertions
  ✘ 224. 00:01:02 Classes as Types and Values
  ✘ 225. 00:00:54 Using Classes in TypeScript
  ✘ 226. 00:02:13 Dive into Classes with Type Predicates
  ✘ 227. 00:02:41 Simplifying TypeScript with Type Predicates
  ✘ 228. 00:01:25 Assertion Functions and Classes
  ✘ 229. 00:01:27 Leverage Assertion Functions for Better Inference in Classes
  ✘ 230. 00:07:44 Class Implementation Following the Builder Pattern
  ✘ 231. 00:04:08 TRPC's Creator on the Builder Pattern
  ✘ 232. 00:01:09 Create a Type Safe Map with the Builder Pattern
  ✘ 233. 00:02:19 Getters and Setters in the Builder Pattern
  ✘ 234. 00:00:41 Debugging the Builder Pattern
  ✘ 235. 00:02:41 Default Generics in the Builder Pattern
  ✘ 236. 00:03:40 Building Chainable Middleware with the Builder Pattern
  ✘ 237. 00:06:37 The Power of Generics and the Builder Pattern
  ✘ 238. 00:03:18 Subclassing in Zod
  ✘ 239. 00:05:24 Where Do External Types Come From?
  ✘ 240. 00:00:59 Extract Types to Extend an External Library
  ✘ 241. 00:02:00 Retrieve Function Parameters from an External Library
  ✘ 242. 00:03:26 Navigating Lodash's Type Definitions
  ✘ 243. 00:01:21 Finding Proper Type Arguments and Generics with Lodash
  ✘ 244. 00:05:15 Passing Type Arguments with Lodash
  ✘ 245. 00:09:06 Navigating Express's Type Definitions
  ✘ 246. 00:01:18 Add Query Params to an Express Request
  ✘ 247. 00:03:44 Make an Express Request Function Generic
  ✘ 248. 00:02:45 Browsing Zod's Types
  ✘ 249. 00:01:39 Create a Runtime and Type Safe Function with Generics and Zod
  ✘ 250. 00:04:38 Infer Runtime Arguments from a Zod Schema
  ✘ 251. 00:01:38 Override External Library Types
  ✘ 252. 00:03:50 Create a Declarations File to Override Types
  ✘ 253. 00:01:31 Identity Functions as an Alternative to the `as const`
  ✘ 254. 00:02:05 Using const type parameters For Better Inference
  ✘ 255. 00:00:47 Add Constraints to an Identity Function
  ✘ 256. 00:02:51 Constraining and Narrowing an Identity Function
  ✘ 257. 00:01:38 Specifying Where Inference Should Not Happen
  ✘ 258. 00:02:17 Fix Inference Issues with F.NoInfer
  ✘ 259. 00:01:10 Find the Generic Flow of an Identity Function
  ✘ 260. 00:02:39 Avoid Duplicate Code in an Identity Function with Generics
  ✘ 261. 00:01:19 Reverse Mapped Types
  ✘ 262. 00:02:17 Inference Inception in an Identity Function
  ✘ 263. 00:00:59 Merge Dynamic Objects with Global Objects
  ✘ 264. 00:02:19 Add Objects to the Global Scope Dynamically
  ✘ 265. 00:01:19 Narrowing with an Array
  ✘ 266. 00:08:30 Narrowing with Arrays and Generics
  ✘ 267. 00:01:59 Create a Type-Safe Request Handler with Zod and Express
  ✘ 268. 00:07:45 Type-Safe Request Handlers with Zod and Express
  ✘ 269. 00:03:55 Building a Dynamic Reducer
  ✘ 270. 00:11:26 Dynamic Reducer with Generic Types
  ✘ 271. 00:01:06 Custom JSX Elements
  ✘ 272. 00:04:01 Adding Custom Elements to JSX.IntrinsicElements
  ✘ 273. 00:52:27 Tejas Kumar Discusses How to Build Bulletproof Apps with TypeScript
  ✘ 274. 00:43:02 Adopting TypeScript at Netflix with Shaundai Person
  ✘ 275. 00:54:35 Mark Erikson on Avoiding Breaking Changes and Improving Maintainability with TypeScript
  ✘ 276. 00:42:01 The TypeScript Culture at Formidable with Kadi Kraman
  ✘ 277. 01:01:20 Colin McDonnell Talks About The Design Choices Behind Zod
  ✘ 278. 00:56:41 TypeScript's History and Growth with Daniel Rosenwasser
  ✘ 279. 00:43:52 Priscila Oliveira on Sentry's TypeScript Migration
  ✘ 280. 00:48:45 Gabriel Vergnaud on Type and Value Level Mapping in TypeScript
  ✘ 281. 00:49:57 Building Familiarity with TypeScript's Syntax and Functionality with Orta Therox
  ✘ 282. 00:40:46 A Look at tRPC with its Creator Alex "KATT" Johansson
  ✘ 283. 00:52:39 Exploring Generics in React Query with Tanner Linsley
  ✘ 284. 00:01:18 Type-Checking React Props With Discriminated Unions
  ✘ 285. 00:01:45 Using Discriminated Unions to Create Flexible Component Props in React
  ✘ 286. 00:00:48 Destructuring Discriminated Unions in React Props
  ✘ 287. 00:02:32 Destructuring vs Accessing Discriminated Union Props
  ✘ 288. 00:05:15 Adding a Prop Required Across Discriminated Union Variants
  ✘ 289. 00:03:37 Resolving Discriminated Union Types with an Intersection
  ✘ 290. 00:02:24 Differentiating Props With a Boolean Discriminator
  ✘ 291. 00:00:49 Discriminated Unions for Conditional Props in TypeScript
  ✘ 292. 00:02:28 Using the Record Type to Represent an Empty Object
  ✘ 293. 00:01:19 Conditionally Require Props With Discriminated Unions
  ✘ 294. 00:02:16 Allow Optional Props Using A Discriminated Union Branch With Undefined Types
  ✘ 295. 00:02:17 Finding a Better Type Definition For A Mapped Component
  ✘ 296. 00:01:23 What's The Difference Between React.ReactNode and React.FC?
  ✘ 297. 00:02:38 Syncing Types without Manual Updates
  ✘ 298. 00:01:05 The `keyof typeof` Pattern
  ✘ 299. 00:04:17 The Partial Autocompletion Quirk
  ✘ 300. 00:01:21 Solving Partial Autocompletion
  ✘ 301. 00:01:43 Extracting Keys and Values from a Type
  ✘ 302. 00:02:19 Using `as const` and Indexed Access Types to Extract Keys and Values from a Type
  ✘ 303. 00:01:25 Ensuring Correct Inference for Prop Types
  ✘ 304. 00:01:18 Comparing `as const`, `as`, and `satisfies`
  ✘ 305. 00:00:54 Inference from a Single Source of Truth
  ✘ 306. 00:03:29 Understanding and Implementing Dynamic Props Mapping in React
  ✘ 307. 00:01:17 DRY out Code with Generic Type Helpers
  ✘ 308. 00:01:27 Implement a Generic Type Helper
  ✘ 309. 00:03:36 Refactoring to a Type Helper
  ✘ 310. 00:04:30 Creating an "All or Nothing" Type Helper for React props
  ✘ 311. 00:01:04 Constraining a Type Helper to Accept Specific Values
  ✘ 312. 00:03:30 Add Generic Constraints to Type Helpers
  ✘ 313. 00:01:50 Adding Type Arguments to a Hook
  ✘ 314. 00:02:56 Adding Type Arguments to a Function
  ✘ 315. 00:01:19 Wrapping a Generic Function Inside of Another
  ✘ 316. 00:04:18 Type Inference with Generic Functions in TypeScript
  ✘ 317. 00:01:46 Applying Generics to Components
  ✘ 318. 00:00:50 Add a Generic Type Argument to a Props Interface
  ✘ 319. 00:01:18 Generics in Class Components
  ✘ 320. 00:01:49 Converting a Class Component to be Generic
  ✘ 321. 00:02:18 Passing Type Arguments To Components
  ✘ 322. 00:01:17 Use the Angle Brackets Syntax to Pass a type to a Component
  ✘ 323. 00:03:55 Generic Inference through Multiple Type Helpers
  ✘ 324. 00:04:49 Adding Generic Type Arguments to Type Helpers
  ✘ 325. 00:02:36 Build a useMutation hook
  ✘ 326. 00:01:59 Refactoring a Generic Hook for Best Inference
  ✘ 327. 00:02:12 Generics vs Discriminated Unions
  ✘ 328. 00:00:40 Refactoring from Generics to a Discriminated Union
  ✘ 329. 00:02:12 Fixing Type Inference in a Custom React Hook
  ✘ 330. 00:08:06 Use 'as const' to Infer a Tuple return type
  ✘ 331. 00:01:56 Strongly Typing React Context
  ✘ 332. 00:01:54 Using Type Arguments to Create A Strongly Typed Context
  ✘ 333. 00:04:18 Using TypeScript to Manage Complex State
  ✘ 334. 00:01:21 Handling Complex State Management with TypeScript Unions
  ✘ 335. 00:01:17 Using Discriminated Unions in useState
  ✘ 336. 00:01:59 Handling Different State Values with Discriminated Unions
  ✘ 337. 00:01:23 Discriminated Tuples in Custom Hooks
  ✘ 338. 00:02:17 Improved Type Safety with Discriminated Tuples in TypeScript
  ✘ 339. 00:01:14 Use Function Overloads for Better Type Inference
  ✘ 340. 00:05:32 Overloading Functions in TypeScript
  ✘ 341. 00:00:59 Mimicking useState Behavior with Function Overloads
  ✘ 342. 00:03:47 Wrapping useState Functionality with Function Overloads
  ✘ 343. 00:01:29 Currying Hooks
  ✘ 344. 00:03:41 Inferring Type Arguments in Curried Hooks
  ✘ 345. 00:01:23 Exploring the React Namespace
  ✘ 346. 00:03:46 Understanding the React Namespace
  ✘ 347. 00:01:31 JSX.Element, React.ReactElement, and React.ReactNode
  ✘ 348. 00:06:06 Understanding React's JSX Types
  ✘ 349. 00:01:45 Strongly Typing Children in React
  ✘ 350. 00:03:08 Strongly Typing Children in React Doesn't Work
  ✘ 351. 00:01:04 Exploring JSX.IntrinsicElements
  ✘ 352. 00:02:55 Understand the Structure of React's JSX.IntrinsicElements
  ✘ 353. 00:02:35 Understanding React's ElementType and ComponentType
  ✘ 354. 00:00:31 Appending to React's Global Namespace
  ✘ 355. 00:01:04 Declaration Merging and the Global Namespace
  ✘ 356. 00:00:53 Modify Existing Interfaces in the Global React Namespace
  ✘ 357. 00:00:53 Extend the Global React namespace with Declaration Merging in TypeScript
  ✘ 358. 00:00:45 Add a New Global Element in TypeScript
  ✘ 359. 00:02:18 Extend JSX.IntrinsicElements with Declaration Merging
  ✘ 360. 00:01:17 Exploring HTML Attribute and Element Types
  ✘ 361. 00:04:40 Navigating HTMLAttribute types
  ✘ 362. 00:00:37 Add Attributes to All Elements with Declaration Merging
  ✘ 363. 00:02:28 Updating the Global Namespace for an Additional Attribute
  ✘ 364. 00:01:30 Strongly Typed Lazy Loading
  ✘ 365. 00:05:07 Strongly Typing Lazy Loaded Components with Generics
  ✘ 366. 00:01:40 Render Props
  ✘ 367. 00:02:38 Typing the Children Prop for Render Props
  ✘ 368. 00:01:37 Records of Components with the Same Props
  ✘ 369. 00:03:34 Infer Shared Props for Multiple Components
  ✘ 370. 00:06:43 The Problem With forwardRef
  ✘ 371. 00:01:03 Fixing forwardRef Locally
  ✘ 372. 00:01:58 Override forwardRef's Behavior Locally
  ✘ 373. 00:01:39 Typing Higher Order Components
  ✘ 374. 00:04:45 Implementing a Generic Higher Order Component
  ✘ 375. 00:01:34 Using Higher Order Components with Generic Components
  ✘ 376. 00:04:51 Add Generic Component Support to a Higher Order Component
  ✘ 377. 00:02:29 The `as` Prop in React
  ✘ 378. 00:07:06 Approaching the `as` Prop with IIMTs and Generics
  ✘ 379. 00:01:27 The `as` Prop with Custom Components
  ✘ 380. 00:03:17 Type Helpers for React Components
  ✘ 381. 00:01:31 The `as` Prop with Defaults
  ✘ 382. 00:05:25 Two Approaches to Defaults for the `as` Prop
  ✘ 383. 00:01:45 The `as` Prop with `forwardRef`
  ✘ 384. 00:07:38 Distributive Omit with the `as` Prop
  ✘ 385. 00:02:50 React Hook Form's Types
  ✘ 386. 00:05:43 Understanding useForm Type Declarations in React Hook Form
  ✘ 387. 00:01:28 Wrapping the useForm Hook from React Hook Form
  ✘ 388. 00:04:55 Creating a Generic Wrapper for useForm
  ✘ 389. 00:01:58 React-Select's Generics
  ✘ 390. 00:06:07 Capture and Extend React Select's Type Definitions
  ✘ 391. 00:03:05 Understanding React Query's Overloads
  ✘ 392. 00:08:01 Targeting Overloads with useQuery
  ✘ 393. 00:01:26 Wrapping useQuery
  ✘ 394. 00:05:43 Handling Type Arguments in a Custom Query Hook

|Hours: 61 hour|
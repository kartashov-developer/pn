[books] @

| let a = 10; -- a: 10, b: undefined
| let b = a; -- a: 10, b: 10
| a = 0; -- a: 0,
| b: 10
| let a = 10;
# Инициализируем переменную, называя её `a`. Присваиваем ей числовое значение |10|.
  | let b = a;
# Инициализируем переменную, называя ее `b`. Присваиваем ей значение `a`.
# Так как |{js}a = 10|, присваиваем `b` числовое значение |10|.
  | a: 10, b: 10;
  | a = 0;
# Присваиваем переменной `a` числовое значение |0|.
  Получается, что `a`=|0|, `b`=|10|.

Ментальные модели .
. Для каждой знакомой фундаментальной концепции программирования(например, 
  переменная или операция с ней) существует набор глубоко укоренившихся 
  аналогий, которые вы с ней связываете. Некоторые из них пришли из реального 
  мира. Другие могут быть перепрофилированы из других областей, котоыре вы 
  изучили первыми(математика). Эти аналогии могут пересекаться и даже 
  противоречить друг другу, но они все равно помогают понять, что происходит в 
  коде.
  К примеру, многие люди впервые узнали о переменных, как о 'коробках' - 
  контейнерах, в которых хранятся данные. Даже, если вы больше не представляете 
  ящики, когда видите переменную, они все равно могут вести себя в вашем 
  воображении 'ящиками'.
  Эти приблизительные представления о том, как что-то работает в голове, 
  известны, как `ментальные модели`. Нужно постораться замечать и анализировать 
  свои ментальные помеди. Вероятно, они представляют собой комбинацтю 
  визуальных, пространственных и механических умственных сокращений. Эта 
  интуиция(например, 'квадратность' переменных) влияет на то, как мы читаем код 
  всю нашу жизнь.
  К сожалению, иногда ментальные модели могут быть ошибочны. Может быть, 
  учебник, который мы прочитали ранее, пожертвовал точностью, чтобы упростить 
  объяснение концепции. Возможно, когда мы начинали изучать JavaScript, мы 
  неправильно 'перенесли' ожидаемое поведение из языка, который изучали ранее. 
  Возможно, мы вывели ментальную модель из какого-то фрагмента кода, но никогда 
  не проверяли ее правильность.
  Хорошая ментальная модель поможет получить уверенность в своем коде, понять и 
  исправить чужой код.
Вселенная JavaScript .
. В начале были `значения`. Что же такое значение? Сложно сказать. Что такое 
  точка в геометрии? Значение - фундаментальное понятие в JavaScript, поэтому мы 
  не можем определить его с помощью других терминов. Вместо этого мы определим 
  его на примерах. Числа и строки являются значениями. Объекты и функции - тоже. 
  Есть также много вещей, которые не являются значениями, например фрагменты 
  нашего кода - например, наши операторы if(if statements), циклы(loops) и 
  объявления переменных(variable declarations).
. Когда мы начинаем строить нашу ментальную модель, одно из первых 
  распространенных заблуждений, которые нам нужно прояснить, состоит в том, что 
  значения - это наш код.
  Вместого этого нам нужно думать о них отдельно - наш код взаимодействует со 
  значениями, но значения существуют в совершенно отдельном пространстве.
  Значения .
  . Вообще-то существует два вида значений. |Примитивные| и |Объекты и функции|.
    Примитивные значения .
    Primitive Values (Immutable|Unchanged|Read-only Values) .
    . Примитивные значения подобны звездам - холодным и далеким, но они всегда 
      рядом, когда нужны. Даже с поверхности моей маленькой планеты, я могу 
      найти и указать на них. Среди прочего это могут быть числа и строки. У 
      всех примитивных значений есть кое-что общее: они являются постоянной 
      частью нашей вселенной JavaScript, так как их нельзя создать, изменить 
      или разрушить. Только указать.
    Объект и функции .
    Object & Function (Mutable Values) .
    . Объекты и функции также являются значениями, но в отличие от примитивных 
      значений, я могу манипулировать ими из своего кода. Если примитивные 
      значений подобны звездам, то объекты и функции подобны астероидам, которые 
      летают вокруг моей планеты - моего кода. Они не являются частью кода, но 
      они достаточно близки, чтобы ими можно было манипулировать.
    | console.log({}); -- {}
    | console.log([]); -- []
    | console.log(x => x * 2); -- [Function (anonymous)]
  . Поначалу все значения могут выглядеть одинаково - просто точки в небе. Но мы 
    здесь, чтобы изучить все различные вещи, плавающие над нами в нашей 
    вселенной JavaScript, поэтому понадобится способ классификации.
  . Мы можем разбить значения на типы - значения одного типа ведут себя 
    одинаково. Всего их 9:
  `Примитивные`
  # {undefined(случайно неопределенный)} используется для непреднамеренно 
    пропущенных значений,
  # {null(специальное неопределенный)} используется для намеренно пропущенных 
    значений,
  # {булевые значения(true и false)} используемые для логических операций,
  # {числа(-100 3.14 и другие)} используемые для математических вычислений,
  # {BigInt(необычные числа)} используемые для математики с большими числами,
  # {строки('привет' "пока" `hi`)} используемые для текста,
  # {Symbols(символы)} используемые для совершения ритуалов и секретов.
  `Объекты и функции`
  # {Объекты({} и другие)} используемые для группировки связанных данных и кода,
  # {Функции(x => x * 2 и другие)} используемые для обращения к коду.
  ! |Других типов нет|.
  В JavaScript нет фундаментальных типов значений, кроме тех, которые мы 
    перечислили. `Остальное все объекты`! Даже массивы, даты и регулярные 
    выражения являются объектами:
    | console.log(typeof([])); // "object"
    | console.log(typeof(new Date())); // "object"
    | console.log(typeof(/(hello|goodbye)/)); // "object"
Values and Variables .
Значения(примитивные, объекты) и переменные(var, let, const) .
. У нас есть небольшая вырезка кода:
. We have a little code snippet:
| let reaction = 'yikes'; -- инициализируем переменную под имененм 'reaction' и присваиваем ей строковое значние 'yikes'
| reaction[0] = '1'; -- выбираем символ в строке под индексом [0] и присваиваем ему новое строковое значение
| console.log(reaction); // 'yikes'
  Мы знаем, что строки - примитивные значения, а массивы - объектный тип. Строки и массивы имеют внешнее сходство. Массив - это последовательность элементов, а строка - последовательность символов.
  | let arr = [212, 9, 506]; -- инициализируем переменную и присваиваем ей объектный тип - массив, в нем содержится 3 числовых примитивных значений
  | let str = "hello"; -- далее инициализируем новую переменную и присваиваем ей строковое примитивное значение
  Чтобы обратиться к первому элементу массива и к первому символу строки, нужно использовать квадратные скобки:
  | console.log(arr[0]); -- первым элементом в массиве, под индексом 0, будет числовое значение примитивного типа 212
  | console.log(str[0]); -- первым символом в строке, под индексом 0, будет символ "h"
  Теперь давайте изменим первый элемент в массиве:
  | arr[0] = 420; -- присваиваем первому элементу в массиве, под индексом 0, новое значение, а именно числовое значение примитивного типа
  | console.log(arr); -- в качестве ответа мы получаем [420, 9, 506], что означает, что присваивание прошло успешно и первый элемент в массиве изменился
  Пора взяться и за первый символ в строке:
  | str[0] = 'j'; -- присваиваем первому символу в строке, под индексом 0, новый символ
  | console.log(str); -- в качестве ответа мы получаем 'hello', что означает, что присваивание не удалось
  Это означает что примитивные типы иммутабельны(неизменяемы, read-only).
  А что, если изменить числовой тип на объектный?
  | let fifty = 50; -- инициализируем переменную и присваиваем ей числовое значение примитивного типа
  | fifty.shades = 'gray'; -- создаем новое свойтво для переменной 'fifty' и задаем ей строкое значение. Но у нас ничего не выйдет.
  50 - числовое значение примитивного типа и мы не можем создавать для него новые свойства. Примитивные типы это звезды на дальнем расстоянии, которые находятся далеко от нашего кода. Мы можем указывать на них, но они всегда будут оставаться там, неизменяемыми.
. Теперь дадим новый кусок кода:
| let pet = 'Narwhal'; -- инициализируем переменную с именем 'pet' и присваиваем ей строкое значение примитивного типа
| pet = 'The kraken'; -- теперь присваиваем нашей переменной новое строковое значение примитивного типа
| console.log(pet); -- 'The kraken', но почему? Примитивные значения иммутабельны! Верно. Но мы же не меняли строковое значние примитивного типа, мы меняем значение переменной. Присваиваем ей новое значение.
  Значит мы создаем новую ментальную связь:
  `Переменные не значения.` Variables are not values.
  `Переменные - указывают на значения.` Variables are point to values.
  Присваение значений к переменной .
  Assigning a Value to a Variable .
  . Переменная - это связь, указывающая на значение. Например, мы можем указать переменной |pet| на строковое значение |'Narwhal'|(Мы присваиваем нашей переменной определенное значение).
  | let pet = "Narwhal"; -- но что, если я хочу другое имя для своего питомца? Не проблема - мы указываем на другое имя(указываем на другое значение).

|Каждое значение принадлежит какому-то типу. Примитивные значения иммутабельны. Мы можем указывать на значения с помощью переменных. Это основа.|

Встречаясь с примитивными значениями .
Meeting the Primitive Values .
  Undefined [js_undefined] .
  . У примитивного типа |undefined| только одно значение - |undefined|.
  | console.log(typeof(undefined)); // "undefined"
  Оно переводится, как несуществует, но это значение и оно реально.
  Null .
  . У примитивного типа |null| только одно значенeие - |null|.
Встречаять с объектами и функциями .
Meeting Objects and Functions .
  Объекты .
  . Объекты включают в себя:
    # массивы,
    # даты,
    # RegExps,
    # другие не примитивные значения.
  . Так как объекты не примитивные значения, значит, что их можно изменять. Они мутабельны. Мы можем обратиться к их свойствам с помощью |[]|(массивы) или |.|(объекты).
  |{js}  
  | let rapper = { name: 'Malicious' };
  | rapper.name = 'Malice'; // Dot notation
  | rapper['name'] = 'No Malice'; // Bracket notation
  . Главное отличие объектов от примитивных значений в том, что мы можем создавать множество объектов.
    | let number = 3;
    | let number1 = 3;
    Эти переменные обращаются к одному значению - цифре 3. |number = number1|
    | let obj = {};
    | let obj1 = {};
    Эти же объекты обращаются к разным значениям объекта. К разным объектам. <obj != obj1>.
    То же самое можно сказать и про массивы, даты и другие объекты.
  Функции .
  . Функции - это значения. Давайте сравним функции с другими значениями.
    . Создадим цикл, который выводит в консоль `число` в течение 7 итераций.
      |{js}  
      | for (let i = 0; i < 7; i++) {
      |   console.log(2);
      | }
      |2| - числовой литерал. Литерал - это выражение. |2| - это числовое значение, а значит, этот цикл выводит всегда одно и тоже значение.
    . Теперь создадим цикл, который 7 раз выводит `объект`.
      |{js}  
      | for (let i = 0; i < 7; i++) {
      |   console.log({});
      | }
      Как много значений получится теперь? Здесь тоже |{}| выступает в качестве литерала, но теперь объектного.
      Но мы знаем, что объекты всегда получаются разные. Поэтому здесь будет 7 совершенно разных объектов.
    . А теперь взглянем на `функции`.
      |{js}  
      | for (let i = 0; i < 7; i++) {
      |   console.log(function() {});
      | }
      Как много разных значений получится? Ответ |7|.
      ! Каждый раз, когда мы выполняем строку кода, содержащую выражение ф-ии, в нашей вселенной появляется совершенно новое значение ф-ии. Так же, как и объекты.
    Вызов функции .
    | let countDwarves = function() { return 7; }; -- <1>
    <1> |1| инициализируем переменную
        |2| присваем ей значение функции
        |3| в функции возвращаем числовой литерал, равный 7
    | let dwarves = countDwarves; -- <2>
    <2> |1| инициализируем переменную
        |2| присваиваем ей функцию countDwarves
    | console.log(dwarves); // в данном случае мы получаем не '7', а ссылку на ф-ию [Function: countDwarves]
    Здесь мы присвоили функции {dwarves} другую функцию {countDwarves}. Но не вызвали {countDwarce}! Поэтому теперь мы ссылаемся на нее. А, если бы вызвали, то получили бы |7|.
    | let countDwarves = function() { return 7; }:
    | let dwarves = countDwarves();
    | console.log(dwarves); // 7
  Сравнения .
  Equalities .
  . Всего есть 3 вида сравнений:
    # Строгое равенство: |a === b|
    # Нестрогое равенство: |a === b|
    # Сравнение одних типов: |Object.is(a, b)|
    Сравнение одних типов .
    |Object.is| не сравнивает два объекта, несмотря на название. `Он сравнивает любые значения`.
    |{js}  
    | console.log(Object.is(2, 2)); // true
    | console.log(Object.is({}, {})); // false
    Строгое сравнение .
    |{js}  
    | console.log(2 === 2); // true
    | console.log({} === {}); // false
      NaN .
      | console.log(NaN === NaN); // false
Прототипы .
. Что за мистическое свойство |__proto__|?
  Любой объект может выбрать другой объект в качестве прототипа.

[js] @

Определение .
. `Алгоротим` - последовательность действия на достижение результата.
Сложность .
  . Сложность по памяти - сколько времени заняло и памяти.
  . Сложность по времени - насколько сильно он затянется, если добавить в него дополнительные возможности.
  |{js}
  | console.time("title");
  | console.timeEnd("title");
Линейный поиск .
. По порядку.
Бинарный поиск .
. Применяется к отсортированному массиву.
. Бинарный поиск выполняется путем проверки того, является ли искомое значение больше, меньше или равно среднему значению в массиве.
  # Если оно меньше, то удаляем правую часть массива.
  # Если оно больше, то удаляем левую часть массива.
  # Если оно равно, то возвращаем значение.
  А в начале, Я в конце. Мы попадаем на середину - "М". Мы отсекаем ненужную часть массива.
  |{js}
  | let sorted = [10, 14, 100, 150, 1000, 2345];
Сортировка пузырьком .
. Бывает по парам, бывает по одному.
. Алгорим состоит из повторяющихся проходов по сортируемому массиву.
  За каждый проход элементы массива последовательно сравниваются попарно и, если порядок в паре неверный, то выполняется обмен элементов.
  Проходы по массиву повторяются N-1 раз или до тех, пока на очередном проходе не окажется, что обмены больше не нужны, что означает - массив отсортирован.
  При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент массива ставится на свое место в конце массива рядом с предыдущим "наибольшим элементом", а наименьший элемент перемещается на одну позицию к началу массива. [https://www.youtube.com/watch?v=ywWBy6J5gz8]
  |{js}
  | const arr = [5, 2, 1, 3, 9, 0, 4, 6, 8, 7];
  | for (let i = 0; i < arr.length; i += 1) {
  |   for (let j = 0; i < arr.length - i; j += 1) {
  |     if (arr[j] > arr[j + 1]) {
  |       const temp = arr[j];
  |       arr[j] = arr[j + 1];
  |       arr[j + 1] = temp;
  |     }
  |   }
  | }
Quicksort .
. В начале выбирается "опорный" элемент массива. Это может быть любое число, но от выбора этого элемента сильно зависит эффективность алгоритма. Если нам известна медиана, то лучше выбирать элемент, который как можно блиЖе к медиане. В нашей реализации алгоритма, мы будем брать самый левый Жлемент, который в результате займет свое место.
Элементы в массиве делятся на две части: слева те, кто меньше опорного элемента, справа те, кто больше. Таким образом опорный элемент занимает свое место и больше никуда не двигается.
Для левого и првого массива действия повторяются рекурсивно.
const arr1 = [15, 4, 10, 100, 2, 34, 6, 8];
|{js}
| function quickSort(items, left, right) {
|   let index;
|   if (items.length > 1) {
|     index = partition(index, left, right);
|     if (left < index - 1) {
|       quickSort(items, left, index - 1);
|     }
|     if (index < right) {
|       quickSort(items, index, right);
|     }
|   }
|   return items;
| };
| quickSort(arr, 0, arr.length - 1);
|{js}
| function partition(items, left, right) {
|   let pivot = items[Math.floor((right + left) / 2)];
|   let i = left;
|   let j = riight;
|   while (i <= j) {
|     while (items[i] < pivot) {
|       i++;
|     }
|     while (items[i] > pivot) {
|       j--;
|     }
|     if (i <= j) {
|       const temp = items[i];
|       items[i] = items[i];
|       items[j] = temp;
|       i++;
|       j--;
|     }
|   }
|   return i;
| }
Хеширование функций, мемоизация .
. Мы запоминаем просчитанные числа записываем.